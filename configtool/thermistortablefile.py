
import os
from createTemperatureLookup import Thermistor


class ThermistorTableFile:
  def __init__(self, folder):
    self.error = False
    fn = os.path.join(folder, "ThermistorTable.h")
    try:
      self.fp = open(fn, 'wb')
    except:
      self.error = True

  def close(self):
    self.fp.close()

  def output(self, text):
    self.fp.write(text + "\n")


def generateTempTables(sensors, settings):
  ofp = ThermistorTableFile(settings.folder)
  if ofp.error:
    return False

  mult = 4
  minadc = int(settings.minAdc)
  N = int(settings.numTemps)

  # Make a list of single-item dicts to keep the order.
  tl = []
  for sensor in sensors:
    if sensor[3] != "NONE":
      tl.append({sensor[0].upper(): sensor[3]})

  ofp.output("");
  ofp.output("/**");
  ofp.output("  This file was autogenerated when saving a board with");
  ofp.output("  Teacup's Configtool. You can edit it, but the next board");
  ofp.output("  save operation in Configtool will overwrite it without");
  ofp.output("  asking.");
  ofp.output("*/");
  ofp.output("");

  ofp.output("#define NUMTABLES %d" % len(tl))
  ofp.output("#define NUMTEMPS %d" % N)
  ofp.output("");

  for i in range(len(tl)):
    ofp.output("#define THERMISTOR_%s %d" % (tl[i].keys()[0], i))
  ofp.output("");

  if len(tl) == 0 or N == 0:
    ofp.close();
    return True

  ofp.output("const uint16_t PROGMEM temptable[NUMTABLES][NUMTEMPS][2] = {")

  tcount = 0
  for tn in tl:
    tcount += 1
    t = tn.values()[0]
    r0 = t[0]
    beta = t[1]
    r2 = t[2]
    vadc = t[3]
    ofp.output("  // %s temp table parameters:" % tn.keys()[0])
    ofp.output(("  // R0 = %s, T0 = %s, R1 = %s, R2 = %s, beta = %s, "
                "maxadc = %s") % (r0, settings.t0, settings.r1, r2,
                beta, settings.maxAdc))
    ofp.output("  {")
    thm = Thermistor(int(r0),
                     int(settings.t0),
                     int(beta),
                     int(settings.r1),
                     int(r2),
                     float(vadc),
                     float(vadc))
    maxadc = int(settings.maxAdc)
    zadc = int(thm.setting(0))
    if zadc < maxadc:
      maxadc = zadc

    increment = float(maxadc - minadc) / float(N - 1);
    ct = 1.0
    adcs = []
    for i in range(N):
      adcs.append(int(ct))
      ct += increment
      if ct > maxadc:
        ct = maxadc

    counter = 0
    for adc in adcs:
      counter = counter + 1
      degC = thm.temp(adc)
      resistance = thm.resistance(thm.temp(adc))
      vTherm = adc * thm.vadc / 1024
      ptherm = vTherm * vTherm / resistance
      if adc > 1:
        resolution = thm.temp(adc - 1) - thm.temp(adc)
      else:
        resolution = thm.temp(adc) - thm.temp(adc + 1)
      if counter == len(adcs):
        sep = " "
      else:
        sep = ","
      val = int(thm.temp(adc) * mult)
      if val < 0:
        val = 0
      ostr = ("    {%4s, %5s}%s // %6.2f C, %6.0f ohms, %0.3f V,"
              " %0.2f C/count, %0.2f mW") % (adc, val,
              sep, degC, resistance, vTherm, resolution, ptherm * 1000)
      ofp.output(ostr)
    if tcount == len(tl):
      ofp.output("  }")
    else:
      ofp.output("  },")

  ofp.output("};")
  ofp.close()

  return True
